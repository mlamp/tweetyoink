# Developer Quickstart: Debug Metadata Display

**Feature**: 005-debug-info-display
**Target Audience**: Developers implementing or extending debug display functionality

## Overview

This feature adds debug metadata visualization to the TweetYoink overlay. When running in development mode, structured debug information from server responses is displayed in a collapsible format below the regular analysis results.

**Key Concepts**:
- Debug blocks detected via `metadata.is_debug` flag
- Only visible in development mode (`import.meta.env.DEV === true`)
- Uses native HTML `<details>/<summary>` for collapsibility
- Extends existing overlay infrastructure (Feature 004)

---

## Prerequisites

Before working on this feature, familiarize yourself with:

1. **TypeScript Strict Mode**: All code uses strict type checking
2. **Existing Overlay Infrastructure** (Feature 004):
   - `src/types/overlay.ts` - ResponseContentItem interface
   - `src/ui/overlay-manager.ts` - Overlay lifecycle management
   - `src/ui/overlay-renderer.ts` - DOM rendering logic
   - `src/services/response-handler.ts` - Server response parsing
3. **Logging Convention**: Use `logger` from `src/utils/logger.ts` (never direct `console.*`)
4. **Vite Environment Variables**: `import.meta.env.DEV` for environment detection

---

## Project Structure

```text
specs/005-debug-info-display/
├── spec.md                  # Feature specification (requirements, user stories)
├── plan.md                  # Implementation plan (this artifact)
├── research.md              # Technical research decisions
├── data-model.md            # TypeScript interfaces and validation rules
├── quickstart.md            # This file (developer onboarding)
├── contracts/
│   └── debug-block-format.yaml  # Expected JSON structure from server
└── tasks.md                 # Task breakdown (generated by /speckit.tasks)

src/
├── types/overlay.ts         # MODIFY: Add DebugContentItem, DebugData interfaces
├── ui/overlay-renderer.ts   # MODIFY: Add renderDebugBlock() function
├── ui/overlay.css           # MODIFY: Add debug block styling
└── services/response-handler.ts  # MODIFY: Add debug block filtering
```

---

## Development Workflow

### 1. Read the Spec

Start with `spec.md` to understand:
- User stories (who needs this feature and why)
- Functional requirements (FR-001 through FR-010)
- Success criteria (measurable outcomes)
- Edge cases and constraints

### 2. Review Research Decisions

Read `research.md` to understand key decisions:
- Why `metadata.is_debug` flag (not separate content type)
- Why `<details>/<summary>` elements (not custom JavaScript)
- Why `import.meta.env.DEV` (not runtime environment check)
- Why built-in `JSON.parse()` (not external library)

### 3. Study Data Model

Review `data-model.md` for:
- TypeScript interfaces (DebugContentItem, DebugData, etc.)
- Validation rules (type guards, error handling)
- Integration points (ParsedResponse modification)

### 4. Check Server Contract

See `contracts/debug-block-format.yaml` for expected JSON structure from server.

### 5. Follow Task Breakdown

Execute tasks in `tasks.md` in dependency order (will be generated by `/speckit.tasks`).

---

## Key Files to Modify

### 1. `src/types/overlay.ts`

**What to add**: TypeScript interfaces for debug data structures

```typescript
// Add after existing ResponseContentItem interface

export interface DebugContentItem extends ResponseContentItem {
  type: 'text';
  content: string; // JSON string
  metadata: {
    is_debug: true;
    title?: string;
    timestamp?: string;
    [key: string]: unknown;
  };
}

export interface DebugData {
  orchestrator_decisions?: OrchestratorDecisions;
  agent_analyses?: AgentAnalysis[];
  execution_metrics?: ExecutionMetric[];
  request_metadata?: RequestMetadata;
  [key: string]: unknown;
}

// ... (copy other interfaces from data-model.md)
```

**Why**: Provides type safety for debug block handling

---

### 2. `src/services/response-handler.ts`

**What to add**: Debug block filtering logic

```typescript
// Modify parseServerResponse to separate debug blocks from regular content

export interface ParsedResponse {
  hasContent: boolean;
  contentItems: ResponseContentItem[];
  debugItems?: DebugContentItem[]; // NEW
  emptyReason?: 'empty-array' | 'no-text-items' | 'non-array-result' | 'error-response';
}

// In parseServerResponse function:
const isDevelopment = import.meta.env.DEV;

// Separate debug blocks from regular content
const debugItems: DebugContentItem[] = [];
const regularItems: ResponseContentItem[] = [];

validatedItems.forEach((item) => {
  if (isDevelopment && item.metadata?.is_debug === true) {
    debugItems.push(item as DebugContentItem);
  } else if (item.type === 'text' || item.type === 'image') {
    regularItems.push(item);
  }
});

return {
  hasContent: regularItems.length > 0,
  contentItems: regularItems,
  debugItems: debugItems.length > 0 ? debugItems : undefined,
};
```

**Why**: Separates debug blocks from regular content before rendering

---

### 3. `src/ui/overlay-renderer.ts`

**What to add**: New `renderDebugBlock()` function

```typescript
// Add near bottom of file, before or after renderContentItem

function renderDebugBlock(item: DebugContentItem): HTMLElement {
  const container = document.createElement('div');
  container.className = 'debug-block';

  // Add title
  const title = document.createElement('h3');
  title.className = 'debug-title';
  title.textContent = item.metadata.title || 'Debug Information';
  container.appendChild(title);

  // Parse JSON
  let debugData: DebugData | null = null;
  try {
    const parsed = JSON.parse(item.content);
    if (typeof parsed === 'object' && parsed !== null) {
      debugData = parsed as DebugData;
    }
  } catch (error) {
    logger.warn('[OverlayRenderer] Failed to parse debug JSON:', error);
  }

  // If parsing failed, show error state
  if (!debugData) {
    return renderDebugError(item.content);
  }

  // Render sections
  if (debugData.orchestrator_decisions) {
    container.appendChild(renderDebugSection('Orchestrator Decisions', debugData.orchestrator_decisions));
  }

  if (debugData.agent_analyses) {
    container.appendChild(renderDebugSection('Agent Analyses', debugData.agent_analyses));
  }

  if (debugData.execution_metrics) {
    container.appendChild(renderDebugSection('Execution Metrics', debugData.execution_metrics));
  }

  if (debugData.request_metadata) {
    container.appendChild(renderDebugSection('Request Metadata', debugData.request_metadata));
  }

  return container;
}

function renderDebugSection(title: string, data: unknown): HTMLElement {
  const details = document.createElement('details');
  details.className = 'debug-section';

  const summary = document.createElement('summary');
  summary.textContent = title;
  details.appendChild(summary);

  const pre = document.createElement('pre');
  pre.className = 'debug-content';
  pre.textContent = JSON.stringify(data, null, 2); // Safe (textContent)
  details.appendChild(pre);

  return details;
}

function renderDebugError(rawContent: string): HTMLElement {
  const container = document.createElement('div');
  container.className = 'debug-block debug-error';

  const title = document.createElement('h3');
  title.textContent = 'Debug Information (Parse Error)';
  container.appendChild(title);

  const errorMsg = document.createElement('p');
  errorMsg.className = 'error-message';
  errorMsg.textContent = 'Failed to parse debug JSON. Raw content displayed below.';
  container.appendChild(errorMsg);

  const pre = document.createElement('pre');
  pre.className = 'debug-raw-content';
  pre.textContent = rawContent;
  container.appendChild(pre);

  return container;
}
```

**Modify renderOverlay**: Add debug block rendering after regular content

```typescript
// In renderOverlay function, after rendering contentItems:

// Render debug blocks if present (development mode only)
if (parsedResponse.debugItems && parsedResponse.debugItems.length > 0) {
  parsedResponse.debugItems.forEach((debugItem) => {
    const debugElement = renderDebugBlock(debugItem);
    contentArea.appendChild(debugElement);
  });
}
```

**Why**: Encapsulates debug-specific rendering logic

---

### 4. `src/ui/overlay.css`

**What to add**: Styles for debug blocks

```css
/* Debug Block Container */
.debug-block {
  margin-top: 2rem;
  padding: 1rem;
  background-color: #f5f5f5;
  border: 2px dashed #999;
  border-radius: 4px;
}

.debug-title {
  margin: 0 0 1rem 0;
  font-size: 1.2rem;
  color: #333;
  font-family: monospace;
}

/* Collapsible Sections */
.debug-section {
  margin-bottom: 0.75rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: white;
}

.debug-section summary {
  padding: 0.5rem;
  cursor: pointer;
  font-weight: bold;
  user-select: none;
  background-color: #e8e8e8;
}

.debug-section summary:hover {
  background-color: #d8d8d8;
}

.debug-section[open] summary {
  border-bottom: 1px solid #ccc;
}

/* Debug Content */
.debug-content {
  padding: 0.75rem;
  margin: 0;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  line-height: 1.4;
  overflow-x: auto;
  white-space: pre;
  background-color: #fafafa;
}

/* Error State */
.debug-error {
  border-color: #d32f2f;
  background-color: #ffebee;
}

.debug-error .error-message {
  color: #d32f2f;
  margin-bottom: 0.5rem;
}

.debug-raw-content {
  padding: 0.5rem;
  background-color: #fff;
  border: 1px solid #d32f2f;
  font-size: 0.8rem;
  max-height: 200px;
  overflow: auto;
}
```

**Why**: Visually distinguishes debug blocks from regular content

---

## Testing Strategy

### Manual Testing

1. **Development Mode Visibility**:
   - Run extension in dev mode (`npm run dev`)
   - Trigger tweet analysis that returns debug block
   - Verify debug section appears at bottom of overlay
   - Verify all sections are collapsed by default

2. **Collapsibility**:
   - Click on "Orchestrator Decisions" header → should expand
   - Click again → should collapse
   - Repeat for all sections
   - Verify JSON is formatted (indented, readable)

3. **Production Mode Hiding**:
   - Build extension for production (`npm run build`)
   - Load production build in browser
   - Trigger tweet analysis with debug block
   - Verify NO debug section appears (only regular content)

4. **Error Handling**:
   - Test with malformed JSON (manually modify server response)
   - Verify error state renders with fallback message
   - Verify raw content is displayed in error state

5. **Edge Cases**:
   - Empty debug block (no sections)
   - Missing sections (only orchestrator decisions, no metrics)
   - Large debug block (80-100KB JSON)
   - Multiple debug blocks in single response

### Validation Checklist

- [ ] TypeScript compiles with zero errors
- [ ] No direct `console.*` usage (only `logger.*`)
- [ ] Debug blocks render within 100ms (check browser DevTools performance tab)
- [ ] Production build has zero debug rendering code (verify bundle size, check console)
- [ ] All FR requirements met (FR-001 through FR-010)
- [ ] All success criteria validated (SC-001 through SC-007)

---

## Common Pitfalls

### 1. Direct console.log Usage

**Wrong**:
```typescript
console.log('Debug data:', debugData);
```

**Correct**:
```typescript
logger.debug('[DebugRenderer] Debug data:', debugData);
```

**Why**: Violates Constitution Principle VI (logging discipline)

---

### 2. Using innerHTML with JSON

**Wrong**:
```typescript
pre.innerHTML = JSON.stringify(data, null, 2);
```

**Correct**:
```typescript
pre.textContent = JSON.stringify(data, null, 2);
```

**Why**: `innerHTML` can execute scripts if JSON contains HTML (XSS risk). Use `textContent` for safety.

---

### 3. Forgetting Environment Check

**Wrong**:
```typescript
// Always render debug blocks
if (item.metadata?.is_debug) {
  renderDebugBlock(item);
}
```

**Correct**:
```typescript
// Only render in development mode
const isDevelopment = import.meta.env.DEV;
if (isDevelopment && item.metadata?.is_debug) {
  renderDebugBlock(item);
}
```

**Why**: Debug blocks must never appear in production (FR-004, SC-004)

---

### 4. Not Handling Missing Sections

**Wrong**:
```typescript
// Will error if orchestrator_decisions is undefined
renderDebugSection('Orchestrator Decisions', debugData.orchestrator_decisions);
```

**Correct**:
```typescript
// Check existence before rendering
if (debugData.orchestrator_decisions) {
  renderDebugSection('Orchestrator Decisions', debugData.orchestrator_decisions);
}
```

**Why**: Server may send partial debug data (graceful degradation)

---

## Debugging Tips

### 1. Enable Verbose Logging

In development, logger.log and logger.debug output to console. Check:
- `[ResponseHandler]` logs for debug block detection
- `[OverlayRenderer]` logs for rendering steps
- `[DebugValidator]` logs for parsing errors

### 2. Inspect Network Requests

Use Chrome DevTools Network tab:
- Find POST request to `/tweets` endpoint
- Check response body for debug blocks
- Verify `metadata.is_debug` flag is present
- Verify JSON structure matches `contracts/debug-block-format.yaml`

### 3. Check Environment Variable

In console:
```javascript
console.log('DEV mode:', import.meta.env.DEV); // Should be true in dev
```

### 4. Inspect DOM

Use Chrome DevTools Elements tab:
- Find `.debug-block` element
- Check `<details>` elements are rendered
- Verify `open` attribute toggles on click
- Check CSS classes are applied

---

## References

- **Feature Spec**: `spec.md` - Complete requirements and user stories
- **Research Decisions**: `research.md` - Why we chose this approach
- **Data Model**: `data-model.md` - TypeScript interfaces and validation
- **Server Contract**: `contracts/debug-block-format.yaml` - Expected JSON structure
- **Constitution**: `.specify/memory/constitution.md` - Project principles
- **Existing Overlay**: Feature 004 docs (if available)

---

## Getting Help

If you encounter issues:

1. Check `spec.md` for requirements clarification
2. Review `research.md` for architectural decisions
3. Validate against `data-model.md` interfaces
4. Check constitution for coding standards
5. Inspect browser console for logger output
6. Review existing overlay code (Feature 004) for patterns

---

## Next Steps After Implementation

1. Manual validation against success criteria (SC-001 through SC-007)
2. Code review (check TypeScript strict mode, logger usage, constitution compliance)
3. Update `implementation-summary.md` (optional) with lessons learned
4. Document any deviations from plan in commit messages
5. Test production build to verify debug code is stripped
