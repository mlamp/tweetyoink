# TweetYoink Development Guidelines

Auto-generated from all feature plans. Last updated: 2025-10-23

## Project Overview

TweetYoink is a Chrome extension that captures tweet data from Twitter/X and sends it to a user-configured backend. This project follows strict constitutional principles emphasizing separation of concerns, TypeScript-first development, and defensive DOM extraction.

## Active Technologies
- TypeScript 5.x with strict mode enabled + Vite 5.x, @crxjs/vite-plugin (Chrome extension Vite plugin), @types/chrome (TypeScript definitions for Chrome APIs), Vitest (unit testing), Playwright (E2E testing), sharp or jimp (icon generation) (001-initial-setup)
- Chrome Storage API (for extension settings), no external database (001-initial-setup)
- TypeScript 5.x with strict mode enabled + Vite 5.x, @crxjs/vite-plugin for Chrome extension bundling (002-post-view-yoink)
- Chrome Extension Storage API (for future settings), currently N/A for console-only MVP (002-post-view-yoink)
- TypeScript 5.x (existing project standard) (003-config-endpoint)
- `chrome.storage.sync` for user configuration, `chrome.storage.local` for request tracker state (003-config-endpoint)
- TypeScript 5.3 with strict mode + Existing Chrome Extension APIs (no new dependencies required) (004-response-overlay)
- N/A (ephemeral overlay state, no persistence) (004-response-overlay)

- **Language**: TypeScript 5.x with strict mode enabled
- **Build Tool**: Vite 5.x with @crxjs/vite-plugin (Chrome extension support)
- **Platform**: Chrome Extension Manifest V3 (service worker architecture)
- **Storage**: Chrome Storage API (for extension settings)
- **Type Definitions**: @types/chrome for Chrome APIs

## Project Structure

```text
tweetyoink/
├── src/
│   ├── types/          # TypeScript interfaces and types
│   ├── extractors/     # DOM extraction logic with fallbacks
│   ├── content-script.ts
│   ├── service-worker.ts
│   └── popup/          # Settings UI
├── public/
│   ├── icons/          # Extension icons (16x16, 48x48, 128x128)
│   └── manifest.json   # Chrome Extension Manifest V3
├── dist/               # Build output (generated by Vite)
├── specs/              # Feature specifications and planning docs
│   └── [###-feature]/  # Individual feature directories
├── .specify/           # Speckit templates and scripts
│   ├── memory/         # Constitution and agent context
│   ├── templates/      # Feature planning templates
│   └── scripts/        # Automation scripts
└── docs/               # Project-wide documentation
```

## Development Commands

```bash
# Install dependencies
npm install

# Build for production (minified, no source maps)
npm run build

# Build for development (unminified, with source maps)
npm run build:dev

# Development mode with watch (auto-rebuild on changes, production mode)
npm run watch

# Development mode with watch (auto-rebuild on changes, development mode with source maps)
npm run watch:dev

# Type checking
npm run type-check

# Development server with HMR
npm run dev
```

### Development vs Production Builds

**Development Mode** (`npm run build:dev` or `npm run watch:dev`):
- **Source maps enabled**: Errors show original TypeScript file and line numbers
- **No minification**: Code is readable for debugging
- **Readable chunk names**: Files keep their original names (no hashes)
- Use this for testing in Chrome Developer Mode

**Production Mode** (`npm run build` or `npm run watch`):
- **No source maps**: Smaller bundle size
- **Full minification**: Optimized for performance
- **Hashed chunk names**: For cache busting
- Use this for publishing to Chrome Web Store

## Code Style & Conventions

### TypeScript Guidelines
- **Strict mode REQUIRED**: All code must compile with `strict: true` in tsconfig.json
- **No `any` types**: Avoid `any` except for justified edge cases (document in comments)
- **Type all Chrome API interactions**: Use @types/chrome definitions
- **Define interfaces for all data structures**: TweetData, UserContext, CapturePayload, etc.

### File Organization
- **Feature-specific docs**: Place in `specs/[###-feature]/` directory
- **Project-wide docs**: Place in `docs/` directory
- **Source code**: Organize by concern in `src/` with clear separation
- **No root clutter**: Only README.md, LICENSE, and config files in root

### Naming Conventions
- **Files**: kebab-case (e.g., `content-script.ts`, `tweet-extractor.ts`)
- **Types/Interfaces**: PascalCase (e.g., `TweetData`, `ExtractorConfig`)
- **Variables/Functions**: camelCase (e.g., `extractTweetData`, `currentUrl`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_CAPTURES_PER_SESSION`)

## Constitutional Principles

**IMPORTANT**: All development must comply with the project constitution at `.specify/memory/constitution.md`

### Core Principles Summary
1. **Separation of Concerns**: Extension and server MUST be separate repositories
2. **LLM-First Data Structure**: DOM parsing over screenshot-based extraction
3. **User Control & Privacy**: User explicitly triggers all captures; backend is configurable
4. **TypeScript-First Development**: Strict type checking, no `any` types
5. **Defensive DOM Extraction**: Fallback selectors and graceful degradation

## Extension Development Notes

### Loading Extension in Chrome

**For Development** (with source maps for better debugging):
1. Run `npm run build:dev` to create dist/ folder
2. Open `chrome://extensions` in Chrome
3. Enable "Developer mode" (top right toggle)
4. Click "Load unpacked"
5. Select the `dist/` folder

**For Production Testing** (optimized build):
1. Run `npm run build` to create dist/ folder
2. Follow steps 2-5 above

### Development Workflow

**Recommended for active development** (with source maps):
1. Run `npm run watch:dev` in terminal (auto-rebuild on changes with source maps)
2. Make code changes in `src/`
3. Reload extension in `chrome://extensions` (click ↻ button)
4. Refresh Twitter/X page if testing content script
5. Total iteration time should be <30 seconds

**Alternative** (production mode, faster builds):
1. Run `npm run watch` in terminal (auto-rebuild on changes, no source maps)
2. Follow steps 2-5 above

### Debugging

**Source Maps**: When building with `--mode development`, errors will show original TypeScript file paths and line numbers instead of cryptic packed vendor.js references. This makes debugging significantly easier in Chrome DevTools.

**DevTools Access**:
- **Service Worker**: Click "service worker" link in chrome://extensions
- **Content Script**: Open page DevTools (F12) on Twitter/X
- **Popup**: Right-click popup → Inspect

All components log with prefixes:
- `[TweetYoink Service Worker]`
- `[TweetYoink Content Script]`
- `[TweetYoink Popup]`

## Recent Changes
- 004-response-overlay: Added TypeScript 5.3 with strict mode + Existing Chrome Extension APIs (no new dependencies required)
- 003-config-endpoint: Added TypeScript 5.x (existing project standard)
- 002-post-view-yoink: Added TypeScript 5.x with strict mode enabled + Vite 5.x, @crxjs/vite-plugin for Chrome extension bundling

<!-- MANUAL ADDITIONS START -->
<!-- MANUAL ADDITIONS END -->
